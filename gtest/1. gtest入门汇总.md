[TOC]

### 1.1 断言

`GTest`提供的断言有致命(Fatal)和非致命(Non-fatal)两个版本。致命断言以`ASSERT_`打头，非致命断言以`EXPECT_`打头。致命断言报错时，单元测试中止并返回；非致命断言报错时程序继续运行，测试其他的断言。断言不局限于在单元测试时使用，任何返回值为`void`的函数都可以使用断言，具体的逻辑请见[此处](https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#assertion-placement)。在`GTest`提供了一下几个类别的断言。

#### 1.1.1 0-元断言

`SUCCESS()`和 `FAIL()`，`SUCCESS()`仅仅用作说明某件事成功，不代表单元测试成功，好像没什么用。`FAIL()`可以被用在控制逻辑中。

```C++
FAIL() << "Fatal Failure";
// 上述一行代码可以用来替代下面的两行代码。
std::cerr << "Fatal Failure" <<std::end;
exit(-1);
```

#### 1.1.2 条件断言

条件断言判断条件是否为真，这里给出了致命和非致命的类型。接下来的断言只给出`ASSERT_xxx`形式,默认是有对应的`EXPECT_xxx`版本。

| Fatal assertion            | Nonfatal assertion         | Verifies             |
| -------------------------- | -------------------------- | -------------------- |
| `ASSERT_TRUE(condition);`  | `EXPECT_TRUE(condition);`  | `condition` is true  |
| `ASSERT_FALSE(condition);` | `EXPECT_FALSE(condition);` | `condition` is false |

```C++
int add(int a, int b);
TEST(GeneralTest, BasicAssertion)
{
    ASSERT_TRUE(add(1, 2) == 3);
    ASSERT_FALSE(add(1, 2) == 2);
}
```

#### 1.1.3 二元比较

二元比较断言比较两个值的关系。这类段言假设 `==`,`<`等运算符在`val1`和`val2`上重载。当比较`C string`(eg. `const char*`)时，这类断言只做指针比较,这和直觉是相反的，请不要使用`ASSERT_EQ`等做`C string`的比较。

| Fatal assertion          | Verifies       |
| ------------------------ | -------------- |
| `ASSERT_EQ(val1, val2);` | `val1 == val2` |
| `ASSERT_NE(val1, val2);` | `val1 != val2` |
| `ASSERT_LT(val1, val2);` | `val1 < val2`  |
| `ASSERT_LE(val1, val2);` | `val1 <= val2` |
| `ASSERT_GT(val1, val2);` | `val1 > val2`  |
| `ASSERT_GE(val1, val2);` | `val1 >= val2` |

```C++
TEST(GeneralTest, BinaryComparison) {
  EXPECT_EQ(add(1,2), add(2, 1));
  EXPECT_GT(add(1,2), 1);
  EXPECT_NE(std::string("a"), std::string("b"));
  EXPECT_EQ(std::string("a"), std::string("a"));
  // when compare std::string and c string, it is string comparison.
  // It use overloaded string comparison operator.
  EXPECT_EQ(std::string("a"), "a"); 
  EXPECT_NE(std::string("a"), "b");

  {
    const char* cstr_1 = "abc";
    const char* cstr_2 = "abc";
    // 虽然两者相等，但是只是指针地址相等
    // a_cstr和b_cstr拥有相同的地址是因为编译器
    // 将相同的字符串常量放到了同一个常量区。
    EXPECT_EQ(cstr_1, cstr_2); 
  }
  {
    const char* cstr_1 = "abc";
    const std::string stdstr = "abc";
    const char* cstr_2 = stdstr.c_str();
    // 反直觉，所以不要用EXPECT_NE做c string的比较
    EXPECT_NE(cstr_1, cstr_2);
  }
}
```



#### 1.1.4 字符串比较

这类断言是比较**C 字符串**的，如果想要比较`std::string`,请使用`ASSERT_EQ`和`ASSERT_NE`。

| Fatal assertion                | Verifies                                                 |
| ------------------------------ | -------------------------------------------------------- |
| `ASSERT_STREQ(str1,str2);`     | the two C strings have the same content                  |
| `ASSERT_STRNE(str1,str2);`     | the two C strings have different contents                |
| `ASSERT_STRCASEEQ(str1,str2);` | the two C strings have the same content, ignoring case   |
| `ASSERT_STRCASENE(str1,str2);` | the two C strings have different contents, ignoring case |

```C++
TEST(GeneralTest, StringComparison)
{
    const char* cstr_1 = "abc";
    const std::string stdstr_1 = "abc";
    const char* cstr_2 = stdstr_1.c_str();
    const std::string stdstr_2 = "AbC";
    const char* cstr_3 = stdstr_2.c_str();

    ASSERT_STREQ(cstr_1,cstr_2);
    ASSERT_STRCASEEQ(cstr_2,cstr_3);
    // ASSERT_STRCASEEQ(stdstr_1,stdstr_2); compile error.
}
```

#### 1.1.5 异常相关断言

这一系列断言检测是否有异常抛出和检查异常类型。

| Fatal assertion                            | Verifies                                          |
| ------------------------------------------ | ------------------------------------------------- |
| `ASSERT_THROW(statement, exception_type);` | `statement` throws an exception of the given type |
| `ASSERT_ANY_THROW(statement);`             | `statement` throws an exception of any type       |
| `ASSERT_NO_THROW(statement);`              | `statement` doesn’t throw any exception           |

```C++
TEST(GeneralTest, ThrowAssertion)
{
    const auto throw_error_lamba = [](){
        throw std::runtime_error("woops!");
    };
    ASSERT_THROW(throw_error_lamba(), std::runtime_error);
    ASSERT_ANY_THROW(throw_error_lamba());
    // 可以直接使用代码块
    ASSERT_NO_THROW({
        int a = 1;
    });
}
```

#### 1.1.5 浮点数断言

浮点数因为round-off error，两个浮点数完全一样的可能性比较低。所以`GTest`提供了一系列近似比较的断言。

| Fatal assertion                 | Verifies                                 |
| ------------------------------- | ---------------------------------------- |
| `ASSERT_FLOAT_EQ(val1, val2);`  | the two `float` values are almost equal  |
| `ASSERT_DOUBLE_EQ(val1, val2);` | the two `double` values are almost equal |

上述系列的断言的近似度为浮点数的4个[Units in the Last Place](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/) (ULPs) 内，简单说就是把所有浮点数排序，4个ULP就是前后四位以内。

下面的断言支持自定义近似度。

| Fatal assertion                       | Verifies                                                     |
| ------------------------------------- | ------------------------------------------------------------ |
| `ASSERT_NEAR(val1, val2, abs_error);` | the difference between `val1` and `val2` doesn’t exceed the given absolute error |

除了这些近似等于外，`GTest`还提供了近似小于等比较运算，为了避免过多宏定义，这些运算通过谓词(predicate)的方式调用。

```C++
TEST(GeneralTest, FloatAssertion)
{
    ASSERT_FLOAT_EQ(1.0000001f, 1.0f);
    // double型的浮点数密度高，1e-7在4ULP以外
    // ASSERT_DOUBLE_EQ(1.0000001, 1.0); 失败
    ASSERT_NEAR(1.009f,1.0f,0.01f);
    // 谓词判断
    EXPECT_PRED_FORMAT2(::testing::FloatLE, 1.0000001f, 1.0f);
}
```

#### 1.1.6 gmock的matcher断言

gmock是另外一个库，它提供了一系列类进行匹配，这些类本质上就是一个predicate。

| Fatal assertion                | Verifies              |
| ------------------------------ | --------------------- |
| `ASSERT_THAT(value, matcher);` | value matches matcher |

```C++
TEST(GeneralTest, GMockMatcher)
{
    const std::string str("Hello 123 world!");
    EXPECT_THAT(str, ::testing::StartsWith("Hello"));
    EXPECT_THAT(str, ::testing::EndsWith("world!"));
    ASSERT_THAT(str, ::testing::HasSubstr("llo"));
    EXPECT_THAT(str, ::testing::MatchesRegex(".*[1-9]{3}.*"));
}
```

#### 1.1.7 类断言(Type Assertion)

对类属性(type traits)进行断言，编译期执行，这个断言相较于`std::type_traits`而言能够产生更加友好的错误信息。

```
// 判断T1和T2是否是同一个类
::testing::StaticAssertTypeEq<T1, T2>();
```

#### 1.1.8 谓词断言

此类型断言允许我们自建谓词进行断言。一个好处是可以提供更加漂亮的错误信息。

| Fatal assertion                   | Verifies                    |
| --------------------------------- | --------------------------- |
| `ASSERT_PRED1(pred1, val1)`       | `pred1(val1)` is true       |
| `ASSERT_PRED2(pred2, val1, val2)` | `pred2(val1, val2)` is true |
| `...`                             | `...`                       |

```C++
bool equal(int m, int n)
{
    return m==n;
}
TEST(GeneralTest, PredAssertion)
{
    const int m = 1;
    const int n = 2;
    EXPECT_PRED2(equal, m, n);
}
// Error message:
// equal(m, n) evaluates to false, where
// m evaluates to 1
// n evaluates to 2
```

我们甚至可以通过一下断言自行定义错误信息输出的格式。

| Fatal assertion                                  | Verifies                                 |
| ------------------------------------------------ | ---------------------------------------- |
| `ASSERT_PRED_FORMAT1(pred_format1, val1);`       | `pred_format1(val1)` is successful       |
| `ASSERT_PRED_FORMAT2(pred_format2, val1, val2);` | `pred_format2(val1, val2)` is successful |
| `...`                                            | …                                        |

`pred_format`函数必须由如下签名

```C++
testing::AssertionResult PredicateFormattern(const char* expr1,
                                             const char* expr2,
                                             ...
                                             const char* exprn,
                                             T1 val1,
                                             T2 val2,
                                             ...
                                             Tn valn);
// A predicate-formatter for asserting that two integers are equal
testing::AssertionResult AssertEqual(const char* m_expr,
                                     const char* n_expr,
                                     int m,
                                     int n) {
    if (equal(m, n)) return testing::AssertionSuccess();

    return testing::AssertionFailure() << m_expr << " and " << n_expr
        << " (" << m << " and " << n << ") are not equal, "
        << "as they are " << m-n << " apart.";
}
TEST(GeneralTest, PredAssertion)
{
    const int m = 2;
    const int n = 1;
    EXPECT_PRED_FORMAT2(AssertEqual, m, n);
}
// Error message:
// m and n (2 and 1) are not equal, as they are 1 apart.
```

### 1.2 夹具

#### 1.2.1 标准夹具

构建测试夹具需要做以下几个工作：

1. 继承`::testing::Test`，类定义以`protected:`开头。
2. 在类中定义测试需要用到的对象，这样可以做到各个`test` 互相独立，互不影响。
3. 如有必要，可以写默认构造函数或者重载`SetUp()`函数来准备测试所需资源。gtest会在运行测试前调用`SetUp()`。`SetUp()`容易被写成`Setup()`，为了避免这种错误，请用`override`关键字促使编译器检测。关于什么时候用构造函数什么时候用`SetUp()`，请参照附录。一般推荐直接使用构造函数和析构函数。
4. 如有必要，可以重载析构函数和`TearDown()`来释放由构造函数或者`SetUp()`创建的资源。
5. 如有必要，定义其他成员函数，并将断言加入成员函数。这样做的一个问题是错误信息只会定位到该成员函数。

当使用测试夹具时，使用`TEST_F()`进行测试，而不是`TEST()`。

```C++
class QueueTest : public ::testing::Test {
    protected:
    void SetUp() override {
        q1_.push(2);
        q0_.push(3);
    }

    void TearDown() override {
        std::cout << "TearDown!" << std::endl;
    }

    std::queue<int> q0_;
    std::queue<int> q1_;
};

// 使用TEST_F定义测试，第一个参数是测试夹具类名，第二个参数是测试名
TEST_F(QueueTest, Test1) {
    // 直接可以使用QueueTest的成员变量
    EXPECT_TRUE(q1_.size() == 1);
    q0_.pop();
    EXPECT_TRUE(q0_.empty());
}

TEST_F(QueueTest, Test2) {
    // 测试之间互不影响
    EXPECT_TRUE(q0_.size() == 1);
}
```

从上面我们看到，两个测试互不影响，这是因为`GTest`为每一个单元测试都创建一个不同的测试夹具。对于`TEST_F(QueueTest, Test1)`而言，其具体的流程如下所示：

1. `GTest` 创建一个`QueueTest`实例`t1`， 其默认构造函数将会被调用。

2. 调用`t1.SetUp()`初始化`t1`。

3. 调用`Test1`中的测试代码。

4. 无论测试成功与否，调用`t1.TearDown()`。

5. 调用`t1`析构函数。

#### 1.2.2 定时测试夹具

```c++
class TimedTest : public testing::Test { 
    protected:  
    // 开始计时，如果别的夹具继承TimedTest，需要显式地调用SetUp和TearDown。
    void SetUp() override{
        start_time_ = time(NULL);  
    }  

    // check if the test was too slow.  
    void TearDown() override{    
        // Gets the time when the test finishes    
        const time_t end_time = time(NULL);    
        // Asserts that the test took no more than ~5 seconds.      
        EXPECT_TRUE(end_time - start_time_ <= 5) << "The test took too long.";  
    }
}
```

### 1.3 数据共享

测试夹具在`test`级别提供了代码复用，`GTest`在`testsuite`甚至整个测试程序`Environment`级别提供了类似的功能。不同于测试夹具，`testsuite`和`Environment`会持续到对应的对象生命期结束，这意味着不同的`test`共享了数据。



#### 1.3.1 TestSuite内部test共享数据

对于每一个`test`，`GTest`都会创造新的`TestSuite`对象，如果要做到`test`共享数据，那么只能通过`TestSuite`中的静态成员变量来保存资源。`GTest`提供静态成员函数来创建和删除这些静态成员变量保有的资源。

要创建共享数据：

1. 在测试夹具类中声明静态成员变量。
2. 在外部定义静态变量，通常会在类声明下方。如果是个指针，就给个`nullptr`。这是C++要求，和`GTest`无关。
3. 在测试夹具类中定义 `static void SetUpTestSuite()` 函数来初始化静态成员变量，定义 `static void TearDownTestSuite()` 函数来释放资源。

`GTest`会自动地在运行第一个`test`之前调用`SetUpTestSuite()`，在最后一个`test`结束后调用`TearDownTestSuite()`。`test`的顺序完全是随机的，请不要依赖`test`的调用顺序。此外，尽可能不要修改静态变量，即使要修改，也请在`test`结束后恢复之前的状态。

```C++
class FooTest : public testing::Test {
    protected:
    // Per-test-suite set-up.
    // Called before the first test in this test suite.
    // Can be omitted if not needed.
    static void SetUpTestSuite() {
        shared_resource_ = new ...;
    }

    // Per-test-suite tear-down.
    // Called after the last test in this test suite.
    // Can be omitted if not needed.
    static void TearDownTestSuite() {
        delete shared_resource_;
        shared_resource_ = nullptr;
    }

    // You can define per-test set-up logic as usual.
    virtual void SetUp() { ... }

    // You can define per-test tear-down logic as usual.
    virtual void TearDown() { ... }

    // Some expensive resource shared by all tests.
    static T* shared_resource_;
};

T* FooTest::shared_resource_ = nullptr;

TEST_F(FooTest, Test1) {
    ... you can refer to shared_resource_ here ...
}

TEST_F(FooTest, Test2) {
    ... you can refer to shared_resource_ here ...
}
```

#### 1.3.2 在整个测试程序内共享数据

刚刚聊了在`TestSuite`内共享数据。但是，往往不同的`TestSuite`也会有相同的数据或者运行环境要求，比如相同的`ENV`参数。这就要求在所有的`TestSuite`开始前我们调用某个函数来设置全局变量，在所有`TestSuite`结束后，释放资源。`GTest`提供了接口来注册这样的函数。

`GTest`将这么一对`Setup`和`TearDown`函数封装在一个类中，该类需要继承`::testing::Environment`。

```C++
class MyEnvironment : public ::testing::Environment {
    public:
    ~MyEnvironment() override {}

    // Override this to define how to set up the environment.
    void SetUp() override {}

    // Override this to define how to tear down the environment.
    void TearDown() override {}
};
```

然后将`MyEnvironment`实例注册进入`GTest`中:

```C++
Environment* ::test::AddGlobalTestEnvironment(Environment* env);
```

当`RUN_ALL_TESTS()`被调用时, 它会按照顺序调用每一个`Environment`的`SetUp()`方法,运行所有测试，逆序调用每一个`Environment`的`TearDown()`方法。

可按照如下方式调用。

```C++
int main(int argc, char **argv){
    testing::InitGoogleTest(&argc, argv);
    // GTest own the pointer.
    testing::AddGlobalTestEnvironment(new MyEnvironment);
    return RUN_ALL_TESTS();
}
```



### 1.4 值参数化测试 Value-Parameterized Test

写单元测试时，往往要对不同的参数组合进行测试，测试代码中就会见到许多循环。一个糟糕的情况是某个函数有六个参数，如果六种参数的笛卡尔直积都测一遍，我们要写六重循环。`GTest`提供了值参数化测试(Value-Parameterized Test)的功能。该功能只支持不同的值作为参数传入。



#### 1.4.1 如何定义值参化测试

首先你需要定义一个测试夹具类，它必须同时继承`testing::Test`和`testing::WithParamInterface<T>`，后一个继承为纯接口类，其中`T`就是我们的测试参数类型。为了方便起见，可以直接继承` testing::WithParamInterface<T>`，如果T是一个指针，用户需要自己管理指针。使用`TEST_P`来定义具体测试。

注意：在值参测试的情况下，如果你的测试夹具需要定义`SetUpTestSuite()` 或者 `TearDownTestSuite()`，他们必须是`public`的。

```
class FooTest :
    public testing::TestWithParam<const char*> {
  // You can implement all the usual fixture class members here.
  // To access the test parameter, call GetParam() from class
  // TestWithParam<T>.
};

// Or, when you want to add parameters to a pre-existing fixture class:
class BaseTest : public testing::Test {
  ...
};
class BarTest : public BaseTest,
                public testing::WithParamInterface<const char*> {
  ...
};

TEST_P(FooTest, DoesBlah) {
  // Inside a test, access the test parameter with the GetParam() method
  // of the TestWithParam<T> class:
  EXPECT_TRUE(foo.Blah(GetParam()));
  ...
}

TEST_P(FooTest, HasBlahBlah) {
  ...
}
```

最后，需要调用`INSTANTIATE_TEST_SUITE_P`来实例化测试夹具以及指定参数集合。`gtest`定义了一系列函数方便我们来产生测试参数，相当于parameter generator。

| Parameter Generator                             | Behavior                                                     |
| ----------------------------------------------- | ------------------------------------------------------------ |
| `Range(begin, end [, step])`                    | Yields values `{begin, begin+step, begin+step+step, ...}`. The values do not include `end`. `step` defaults to 1. |
| `Values(v1, v2, ..., vN)`                       | Yields values `{v1, v2, ..., vN}`.                           |
| `ValuesIn(container)` and `ValuesIn(begin,end)` | Yields values from a C-style array, an STL-style container, or an iterator range `[begin, end)` |
| `Bool()`                                        | Yields sequence `{false, true}`.                             |
| `Combine(g1, g2, ..., gN)`                      | Yields all combinations (Cartesian product) as std::tuples of the values generated by the `N` generators. |

```C++
// The first parameter is just a prefix to the test suite name. 
// Pick different prefix for different instantiatioin.
// Following command will generate these test names:
// InstantiationName/FooTest.DoesBlah/0 for "meeny"
// InstantiationName/FooTest.DoesBlah/1 for "miny"
// InstantiationName/FooTest.DoesBlah/2 for "moe"
// InstantiationName/FooTest.HasBlahBlah/0 for "meeny"
// InstantiationName/FooTest.HasBlahBlah/1 for "miny"
// InstantiationName/FooTest.HasBlahBlah/2 for "moe"    
INSTANTIATE_TEST_SUITE_P(InstantiationName,
                         FooTest,
                         testing::Values("meeny", "miny", "moe"));
                     
```

gtest允许我们对夹具多次实例化，下面的命令会将`FooTest`再实例化一次。

```C++
// Newly generated tests:
// AnotherInstantiationName/FooTest.DoesBlah/0 for "cat"
// AnotherInstantiationName/FooTest.DoesBlah/1 for "dog"
// AnotherInstantiationName/FooTest.HasBlahBlah/0 for "cat"
// AnotherInstantiationName/FooTest.HasBlahBlah/1 for "dog"
const char* pets[] = {"cat", "dog"};
INSTANTIATE_TEST_SUITE_P(AnotherInstantiationName, FooTest,
                         testing::ValuesIn(pets));
```

`INSTANTIATE_TEST_SUITE_P`的最后一个参数是打印参数的`functor`，作为测试名的后缀。如果不提供，会使用C++的标准输出流的重载；如果没有重载，直接打印二进制。这个函数接受一个参数`testing::TestParamInfo<class ParamType>`,返回`std::string`。

testing::PrintToStringParamName 是一个内置的后缀生成器， 它的返回值是testing::PrintToString(GetParam())。

```C++
class MyTestSuite : public testing::TestWithParam<int> {};

TEST_P(MyTestSuite, MyTest)
{
    std::cout << "Example Test Param: " << GetParam() << std::endl;
}

INSTANTIATE_TEST_SUITE_P(MyGroup, MyTestSuite, testing::Range(0, 10),
                         testing::PrintToStringParamName());
```

我们也可以提供自定义的functor：

```C++
enum class MyType { MY_FOO = 0, MY_BAR = 1 };

class MyTestSuite : public testing::TestWithParam<std::tuple<MyType, std::string>> {
};

INSTANTIATE_TEST_SUITE_P(
    MyGroup, MyTestSuite,
    testing::Combine(
        testing::Values(MyType::VALUE_0, MyType::VALUE_1),
        testing::ValuesIn("", "")),
    [](const testing::TestParamInfo<MyTestSuite::ParamType>& info) {
        std::string name = absl::StrCat(
            std::get<0>(info.param) == MY_FOO ? "Foo" : "Bar", "_",
            std::get<1>(info.param));
        absl::c_replace_if(name, [](char c) { return !std::isalnum(c); }, '_');
        return name;
    });
```

### 1.5 类型化测试 Type|Type-parameterized Test

之前提到了值参数化，`Gtest`还提供了将类型作为参数的功能，比如可以用来测试同一接口的不同实现。它一共有两种实现方式，`Typed Test`和`Type-Parameterized Test`。



#### 1.5.1 如何定义 Typed Tests

假设你有同一个接口类的不同实现，想要测试它们是否满足一些相同的要求。或者说你想要测试某些类是否满足同样的`concept`。在上述两种情况中，你都需要将相同的测试逻辑应用于不同的类。

首先你需要定义一个测试夹具模版(template)，它测模版参数即为想要测试的类。

```C++
template <typename T>
class FooTest : public testing::Test {
    public:
    ...
        using List = std::list<T>;
    static T shared_;
    T value_;
};
```

接下来我们实例化测试夹具。注意使用`using`是必须的，否则`TYPED_TEST_SUITE`在宏展开时会将类型里面的逗号误认为是新的宏参数。

```C++
using MyTypes = ::testing::Types<char, int, unsigned int>;
TYPED_TEST_SUITE(FooTest, MyTypes);
```

接下来使用`TYPED_TEST()`而不是`TEST_F()`来定义具体的测试。

```C++
TYPED_TEST(FooTest, DoesBlah) {
    // Inside a test, refer to the special name TypeParam to get the type
    // parameter.  Since we are inside a derived class template, C++ requires
    // us to visit the members of FooTest via 'this'.
    TypeParam n = this->value_;

    // To visit static members of the fixture, add the 'TestFixture::'
    // prefix.
    n += TestFixture::shared_;

    // To refer to typedefs in the fixture, add the 'typename TestFixture::'
    // prefix.  The 'typename' is required to satisfy the compiler.
    typename TestFixture::List values;

    values.push_back(n);
    ...
}

TYPED_TEST(FooTest, HasPropertyA) { ... }
```

#### 1.5.2 如何定义 Typed-Parameterized Tests

相较于上面的类型参数化测试，此种测试方法不需要提前知道被测类型，只需在实例化时给出即可。同一个程序中可以实例化多次。

首先定义一个测试夹具：

```C++
template <typename T>
class FooTest : public testing::Test {
  ...
};
```

接着声明该测试夹具是一个类型参数化的`test suite`：

```C++
TYPED_TEST_SUITE_P(FooTest);
```

接下来使用`TYPED_TEST_P()`来定义具体测试。

```C++
TYPED_TEST_P(FooTest, DoesBlah) {
  // Inside a test, refer to TypeParam to get the type parameter.
  TypeParam n = 0;
  ...
}

TYPED_TEST_P(FooTest, HasPropertyA) { ... }
```

最重要的环节是要将具体测试注册如测试集中:

```C++
// The first agrument is the test suite name.
// the following arguments are the test name.
REGISTER_TYPED_TEST_SUITE_P(FooTest,
                            DoesBlah, HasPropertyA);
```

最后实例化测试夹具：

```C++
// When there is only type, just use it directly.
INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, int);
INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, tyesting::Types<int,double,float,char>);
```



### 1.6 死亡测试





大多数单元测试的被测程序发生故障时要么返回错误码，要么返回异常，但是有时候程序碰到内存污染或者安全漏洞问题时，必须直接停止程序。程序都挂了，怎么测试呢？可以将函数指针注册入`signal`来检测，GTest封装好了方便的接口供我们调用，死亡测试。



因为某些条件触发的进程死亡才叫死亡测试。更一般的说，任何一个检查某个程序按照预定规则停机的测试都叫做死亡测试。当测试一段代码抛出异常时，我们不叫它死亡测试，因为我们可以接住异常，可以使用异常断言进行测试。

如果你想测试由于`EXPECT_*()/ASSERT_*()`引起的程序停止，可以看`Catching Failures`。

#### 1.6.1 如何书写死亡测试

Gtest提供了以下宏来做死亡测试：

| Fatal assertion                                  | Nonfatal assertion                               | Verifies                                                     |
| ------------------------------------------------ | ------------------------------------------------ | ------------------------------------------------------------ |
| `ASSERT_DEATH(statement, matcher);`              | `EXPECT_DEATH(statement, matcher);`              | `statement` crashes with the given error                     |
| `ASSERT_DEATH_IF_SUPPORTED(statement, matcher);` | `EXPECT_DEATH_IF_SUPPORTED(statement, matcher);` | if death tests are supported, verifies that `statement` crashes with the given error; otherwise verifies nothing |
| `ASSERT_DEBUG_DEATH(statement, matcher);`        | `EXPECT_DEBUG_DEATH(statement, matcher);`        | `statement` crashes with the given error **in debug mode**. When not in debug (i.e. `NDEBUG` is defined), this just executes `statement` |
| `ASSERT_EXIT(statement, predicate, matcher);`    | `EXPECT_EXIT(statement, predicate, matcher);`    | `statement` exits with the given error, and its exit code matches `predicate` |

`statement`是导致程序停机的程序，`predicate`是一个评估退出码(exit code)的程序，`matcher` 要么是`gMock`的`matcher`，要么是正则表达式，来匹配`const std::string&`由`stderr`的输出。

一个谓词`predicate` 必须接受一个`int`返回`bool`。 死亡测试只有在谓词返回`true`时才加成功。GTest已经定义了一些谓词来处理最常见的情况。

```C++
// This expression is true if the program exited normally with the given exit code.
::testing::ExitedWithCode(exit_code)

    //This expression is true if the program was killed by the given signal.
    testing::KilledBySignal(signal_number) // Not available on Windows.
```

死亡测试成功要满足三个条件：

1. statement是否`abort`或者`exit`
2. 在使用`ASSERT_EXIT`和`EXPECT_EXIT`时， 退出状态是否满足谓词；在使用`ASSERT_DEATH`和 `EXPECT_DEATH`时，退出码是否非零。
3. stderr的输出是够满足`matcher`。

特别的，如果因为`ASSERT_*`或者`EXPECT_*`导致的程序失败不会导致死亡测试失败。

```C++
// calling Foo(5) causes the process to die with the given error message,
TEST(MyDeathTest, Foo) {
    // This death test uses a compound statement.
    ASSERT_DEATH({
        int n = 5;
        Foo(&n);
    }, "Error on line .* of Foo()");
}

// calling NormalExit() causes the process to print "Success" to stderr and exit with exit code 0,
TEST(MyDeathTest, NormalExit) {
    EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), "Success");
}

// calling KillMyself() kills the process with signal SIGKILL.
TEST(MyDeathTest, KillMyself) {
    EXPECT_EXIT(KillMyself(), testing::KilledBySignal(SIGKILL),
                "Sending myself unblockable signal");
}
```

#### 1.6.1 正则表达式

| Expression | Meaning                                                      |
| ---------- | ------------------------------------------------------------ |
| `c`        | matches any literal character `c`                            |
| `\\d`      | matches any decimal digit                                    |
| `\\D`      | matches any character that’s not a decimal digit             |
| `\\f`      | matches `\f`                                                 |
| `\\n`      | matches `\n`                                                 |
| `\\r`      | matches `\r`                                                 |
| `\\s`      | matches any ASCII whitespace, including `\n`                 |
| `\\S`      | matches any character that’s not a whitespace                |
| `\\t`      | matches `\t`                                                 |
| `\\v`      | matches `\v`                                                 |
| `\\w`      | matches any letter, `_`, or decimal digit                    |
| `\\W`      | matches any character that `\\w` doesn’t match               |
| `\\c`      | matches any literal character `c`, which must be a punctuation |
| `.`        | matches any single character except `\n`                     |
| `A?`       | matches 0 or 1 occurrences of `A`                            |
| `A*`       | matches 0 or many occurrences of `A`                         |
| `A+`       | matches 1 or many occurrences of `A`                         |
| `^`        | matches the beginning of a string (not that of each line)    |
| `$`        | matches the end of a string (not that of each line)          |
| `xy`       | matches `x` followed by `y`                                  |

#### 1.6.3 死亡测试的原理

`ASSERT_EXIT()`会生成一个单独的进程来执行`statement`。具体实现取决于平台和配置变量`::testing::GTEST_FLAG(death_test_style)`（它通过命令行`--gtest_death_test_style`）配置。

- 在POSIX系统上，

    ```
    fork()
    ```

    或者

    ```
    clone()
    ```

    被用来产生自进程。

    - 当配置变量是`fast`时，死亡测试会立即执行。
    - 当配置变量是`threadsafe`时，子进程会重新执行单元测试二进制文件，但是仅仅会执行那个被测的死亡测试。

- 在windows系统上，会使用`CreateProcess()`产生子进程。

### 1.7 子程序(subroutine)配置

当我们将测试命令放入子程序中时，不做特殊处理，报错信息仅会提供subroutine的行数，不利于调试。GTest提供了相关的功能允许我们输出更好的调试信息。



#### 提供Trace信息

如果一个被测试的子程序被调用多次，当其内部发生故障时，我们很难得知错误的调用地点发生在何处，我们可以使用`SCOPED_TRACE`来提供提供有效信息。

```
// message can be anything streamable to std::ostream. 
SCOPED_TRACE(message);
ScopedTrace trace("file_path", line_number, message);
```

`message`可以是任何一个可以被`std::ostream`输出的对象。`SCOPED_TRACE`会将当期的文件名、行号、`message`放到错误输出信息中。`ScopedTrace` 允许我们自定义相关信息。正如`scope`名字所言，一旦离开作用范围，这些效果会消失。

例如：

```
void Sub1(int n) {
   EXPECT_EQ(Bar(n), 1);
   EXPECT_EQ(Bar(n + 1), 2);
}

TEST(FooTest, Bar) {
   {
     SCOPED_TRACE("A");  // This trace point will be included in
                         // every failure in this scope.
     Sub1(1);
   }
   // Now it won't.
   Sub1(9);
 }
```

会产生如下信息：

```
path/to/foo_test.cc:11: Failure
Value of: Bar(n)
Expected: 1
  Actual: 2
Google Test trace:
path/to/foo_test.cc:17: A

path/to/foo_test.cc:12: Failure
Value of: Bar(n + 1)
Expected: 2
  Actual: 3
```

几个使用的建议：

1. 大多数时候在测试的开头使用`SCOPED_TRACE`就足够了。
2. 如果在循环中使用子程序，可以将循环信息放入`message`中。
3. 有时候一个行号就够用了，可以将`message`设为`""`。
4. 当发生作用域嵌套时，所有信息都会被输出。

#### 传递致命错误

一个常见的陷阱是`ASSERT_*`和`FAIL*`错误发生在子程序中时，仅有子程序直接跳出，其他测试如常进行。

```
void Subroutine() {
  // Generates a fatal failure and aborts the current function.
  ASSERT_EQ(1, 2);

  // The following won't be executed.
  ...
}

TEST(FooTest, Bar) {
  Subroutine();  // The intended behavior is for the fatal failure
                 // in Subroutine() to abort the entire test.

  // The actual behavior: the function goes on after Subroutine() returns.
  int* p = nullptr;
  *p = 3;  // Segfault!
}
```

为了避免这个问题，GTest提供三种解决方案。

#### 将致命错误变为异常

```
class ThrowListener : public testing::EmptyTestEventListener {
  void OnTestPartResult(const testing::TestPartResult& result) override {
    if (result.type() == testing::TestPartResult::kFatalFailure) {
      throw testing::AssertionException(result);
    }
  }
};
int main(int argc, char** argv) {
  ...
  testing::UnitTest::GetInstance()->listeners().Append(new ThrowListener);
  return RUN_ALL_TESTS();
}
```

#### 使用特殊的宏

| Fatal assertion                       | Nonfatal assertion                    | Verifies                                                     |
| ------------------------------------- | ------------------------------------- | ------------------------------------------------------------ |
| `ASSERT_NO_FATAL_FAILURE(statement);` | `EXPECT_NO_FATAL_FAILURE(statement);` | `statement` doesn’t generate any new fatal failures in the current thread. |

它会将整个测试线程杀死。

#### 通过特殊命令检查

在`::testing::Test`中的`HasFatalFailure()`会反馈当前测试中是否有致命错误发生。这允许我们提前结束测试。

```
class Test {
 public:
  ...
  static bool HasFatalFailure();
};
```

典型的使用方法：

```
TEST(FooTest, Bar) {
  Subroutine();
  // Aborts if Subroutine() had a fatal failure.
  if (HasFatalFailure()) return;

  // The following won't be executed.
  ...
}
```

### 1.8 测试事件处理

GTest提供了一套`event listener API`以支持在测试运行过程中实时监控事件。事件包括测试程序、测试集、测试的开始结束。我们可以对GTest做二次开发。



#### 1.8.1 如何定义Event Listener

必须继承`testing::TestEventListener`或者`testing::EmptyTestEventListener`。第一个是一个纯抽象类，每一个虚函数都要重载。第二个是空函数，只需重载我们关心的虚函数。

当一个事件触发时，它的上下文(context)作为参数送入处理函数。

1. UnitTest 反映了整个测试程序的状态
2. TestSuite 测试集的状态
3. TestInfo 具体测试的状态
4. TestPartResult 测试结果

```
class MinimalistPrinter : public testing::EmptyTestEventListener {
  // Called before a test starts.
  virtual void OnTestStart(const testing::TestInfo& test_info) {
    printf("*** Test %s.%s starting.\n",
           test_info.test_suite_name(), test_info.name());
  }

  // Called after a failed assertion or a SUCCESS().
  virtual void OnTestPartResult(const testing::TestPartResult& test_part_result) {
    printf("%s in %s:%d\n%s\n",
           test_part_result.failed() ? "*** Failure" : "Success",
           test_part_result.file_name(),
           test_part_result.line_number(),
           test_part_result.summary());
  }

  // Called after a test ends.
  virtual void OnTestEnd(const testing::TestInfo& test_info) {
    printf("*** Test %s.%s ending.\n",
           test_info.test_suite_name(), test_info.name());
  }
};
```

#### 1.8.2 如何使用Event Listener

为了使用Event Listener，我们必须在主函数中注册，注册发生在`RUN_ALL_TESTS()`之前。可以注册多个Event Listener。

```
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  // Gets hold of the event listener list.
  testing::TestEventListeners& listeners =
      testing::UnitTest::GetInstance()->listeners();
  // Adds a listener to the end.  googletest takes the ownership.
  listeners.Append(new MinimalistPrinter);
  return RUN_ALL_TESTS();
}
```

除了我们自定义的Event Listener，GTest本身有默认的处理函数，我们可以将其关闭。

```
delete listeners.Release(listeners.default_result_printer());
listeners.Append(new MinimalistPrinter);
return RUN_ALL_TESTS();
```

#### 1.8.3 在Listener中产生错误信息

你可以使用`EXPECT_*()`, `ASSERT_*()`, `FAIL()`等宏来处理错误信息。也有一些约束：

1. 不可以在`OnTestPartResult`中产生错误信息。否则会造成`OnTestPartResult`递归调用。
2. 不可以在`OnTestPartResult`的Listener中产生任何错误信息。

### 1.9 运行测试



### 1.20 杂项

主要介绍测试私有代码、动态注册测试、获取测试名的功能。

#### 1.20.1 测试私有代码

[gtest官方文档](http://code.google.com/p/googletest/wiki/GoogleTestAdvancedGuide#Private_Class_Members)中，也提到了对私有成员的处理，方法不外乎两种：一是使用friend关键字，骗取信任得以通行；二是重构采用Pimpl模式，公共类中只暴露接口，而实现类中暴露所有细节(public)，测试时包含实现类即可。

- 使用friend关键字
    gtest提供了一个`FRIEND_TEST`的宏，用来将一个test声明为产品类的友元。其缺点是显而易见的。一是需要往产品类中添加纯测试代码；二是每加一个test，需要在产品类中添加一项`FRIEND_TEST`。

```C++
// foo.h
class Foo {
    private:
    FRIEND_TEST(FooTest, BarReturnsZeroOnNull);

    int Bar(void* x);
};

// foo_test.cc

TEST(FooTest, BarReturnsZeroOnNull) {
    Foo foo;
    EXPECT_EQ(foo.Bar(NULL), 0);  // Uses Foo's private member Bar().
}
```

请注意你的被测类和测试夹具需要在同一个`namespace`下。
如果被测类是

```C++
namespace my_namespace {

    class Foo {
        friend class FooTest;
        FRIEND_TEST(FooTest, Bar);
        FRIEND_TEST(FooTest, Baz);
    };

}  // namespace my_namespace
```

测试代码必须为：

```C++
namespace my_namespace {

    class FooTest : public testing::Test {
        protected:
        ...
    };

    TEST_F(FooTest, Bar) { ... }
    TEST_F(FooTest, Baz) { ... }

}  // namespace my_namespace
```

- 重构采用Pimpl模式
    我认可Pimpl模式，但同时我也不会对所有的类都这么做。所以如果让我只是为了支持测试而做这样的重构，我可能并不情愿。况且，手工重构很麻烦，而我手头也没有这么个自动化的工具。（当然，我相信这是可以自动化的）

```C++
#ifdef GTEST
#define private public
#define protected public
#endif
```



**更新：**

 在gtest的google group中就这个问题提出了讨论，大家指出这种方式的问题在于：

 

-  使得访问私有成员过分容易，从而导致写出来的test访问私有成员的可能性增大。测试访问了私有成员，也就是依赖于实现，这让单元测试成为你重构的负担，而不是保证。
-  万战勇同学也指出，这种方法是不标准的C++用法: 一是C++标准不允许重定义关键词，所以这种方法即使此时在你当前的编译器上是可行的，你也不能保证将来，或者在其他编译器上可行；二是public, protected private等访问修饰符可能会影响对象成员的布局，这样当你的测试是直接链接到产品代码时会有些问题。

 

所以，除非你对以上两点十分清楚并且可以接受，不然，还是使用官方的FRIEND_TEST要更好一些。

 

- 因为每一个需要访问私有成员的test都需要在产品代码上加上一项 FRIEND_TEST，这会让你思考：我真的需要访问私有成员吗？有没有不用访问私有成员的方法？ 从而帮助形成更好的设计与测试
- 因为每一个依赖于实现的test都显式的登记在案，这样当你的实现细节有所改变时，你知道会影响哪些test



\#define private public的一个致命问题在于如果你使用的那个类是事先编译好的DLL或Lib，你改变访问修饰符使用这个已经被编译好的类极有可能出现link error --- 因为你压根用的就是另外一个类了。现实中，我们或多或少，或直接或间接的会用到其他的库，所以这么做是应该被禁止的。 这点其实是万同学提出来的第二点的扩展。





#### 1.20.2 动态注册测试

使用宏来定义测试是静态的，编译期已知的。GTest提供了动态加载功能，如非必须，不推荐使用。

```C++
// The factory argument is a factory callable (move-constructible) object or function pointer that creates a new instance of the Test object. It handles ownership to the caller. The signature of the callable is Fixture*(), where Fixture is the test fixture class for the test. All tests registered with the same test_suite_name must return the same fixture type. This is checked at runtime.
template <typename Factory>
TestInfo* RegisterTest(const char* test_suite_name, const char* test_name,
                       const char* type_param, const char* value_param,
                       const char* file, int line, Factory factory);
```

它必须在`RUN_ALL_TESTS`被调用前调用。

```C++
class MyFixture : public testing::Test {
    public:
    // All of these optional, just like in regular macro usage.
    static void SetUpTestSuite() { ... }
    static void TearDownTestSuite() { ... }
    void SetUp() override { ... }
    void TearDown() override { ... }
};

class MyTest : public MyFixture {
    public:
    explicit MyTest(int data) : data_(data) {}
    void TestBody() override { ... }

    private:
    int data_;
};

void RegisterMyTests(const std::vector<int>& values) {
    for (int v : values) {
        testing::RegisterTest(
            "MyFixture", ("Test" + std::to_string(v)).c_str(), nullptr,
            std::to_string(v).c_str(),
            __FILE__, __LINE__,
            // Important to use the fixture type as the return type here.
            [=]() -> MyFixture* { return new MyTest(v); });
    }
}
...
    int main(int argc, char** argv) {
    std::vector<int> values_to_test = LoadValuesFromConfig();
    RegisterMyTests(values_to_test);
    ...
        return RUN_ALL_TESTS();
}
```

#### 1.20.3 获取测试名

我们有时候需要在程序运行是获取测试名，例如在`SetUp()`函数中根据测试名进行配置。

`::testing::TestInfo`提供了这种信息。

```C++
namespace testing {
    class TestInfo {
        public:
        // Returns the test suite name and the test name, respectively.
        //
        // Do NOT delete or free the return value - it's managed by the
        // TestInfo class.
        const char* test_suite_name() const;
        const char* name() const;
    };

}
```

在测试中，我们可以通过如下方式获取：

```C++
// Gets information about the currently running test.
// Do NOT delete the returned object - it's managed by the UnitTest class.
const testing::TestInfo* const test_info =
    testing::UnitTest::GetInstance()->current_test_info();

printf("We are in test %s of test suite %s.\n",
       test_info->name(),
       test_info->test_suite_name());
```

### 参考

[Googletest Primer](https://github.com/google/googletest/blob/master/googletest/docs/primer.md)

[Advanced googletest Topics](https://github.com/google/googletest/blob/master/googletest/docs/advanced.md)

[用gtest测试类的私有成员 - 爱码网 (likecs.com)](https://www.likecs.com/show-305576422.html)

[分类: 单元测试 | 豌豆哥的小站 (gitee.io)](https://tao-fu.gitee.io/categories/单元测试/)



### 附录

文章中所有代码块的集合

```C++
#include <exception>
#include <iostream>
#include <stdexcept>
#include <string>

#include "gtest/gtest.h"
#include "gmock/gmock.h"

namespace {
template <typename T>
T add(const T a, const T b)
{
  return a + b;
}
// 利用TEST()宏来定义命名一个测试
// 第一个变量名是测试集的名字，第二个变量名是
// 测试集中某个测试的名字。不同测试集中的测试可以
// 有相同的名字。
TEST(GeneralTest, BasicAssertion)
{
  ASSERT_TRUE(add(1, 2) == 3);
  ASSERT_FALSE(add(1, 2) == 2);
}

TEST(GeneralTest, BinaryComparison) {
  EXPECT_EQ(add(1,2), add(2, 1));
  EXPECT_GT(add(1,2), 1);
  EXPECT_NE(std::string("a"), std::string("b"));
  EXPECT_EQ(std::string("a"), std::string("a"));
  // when compare std::string and c string, it is string comparison.
  // It use overloaded string comparison operator.
  EXPECT_EQ(std::string("a"), "a"); 
  EXPECT_NE(std::string("a"), "b");

  {
    const char* cstr_1 = "abc";
    const char* cstr_2 = "abc";
    // 虽然两者相等，但是只是指针地址相等
    // a_cstr和b_cstr拥有相同的地址是因为编译器
    // 将相同的字符串常量放到了同一个常量区。
    EXPECT_EQ(cstr_1, cstr_2); 
  }
  {
    const char* cstr_1 = "abc";
    const std::string stdstr = "abc";
    const char* cstr_2 = stdstr.c_str();
    // 反直觉，所以不要用EXPECT_NE做c string的比较
    EXPECT_NE(cstr_1, cstr_2);
  }
}

TEST(GeneralTest, StringComparison)
{
  const char* cstr_1 = "abc";
  const std::string stdstr_1 = "abc";
  const char* cstr_2 = stdstr_1.c_str();
  const std::string stdstr_2 = "AbC";
  const char* cstr_3 = stdstr_2.c_str();

  ASSERT_STREQ(cstr_1,cstr_2);
  ASSERT_STRCASEEQ(cstr_2,cstr_3);
  // ASSERT_STRCASEEQ(stdstr_1,stdstr_2); compile error.
}


TEST(GeneralTest, ThrowAssertion)
{
  const auto throw_error_lamba = [](){
    throw std::runtime_error("woops!");
  };
  ASSERT_THROW(throw_error_lamba(), std::runtime_error);
  ASSERT_ANY_THROW(throw_error_lamba());
  // 可以直接使用代码块
  ASSERT_NO_THROW({
    int a = 1;
  });
}

TEST(GeneralTest, FloatAssertion)
{
  ASSERT_FLOAT_EQ(1.0000001f, 1.0f);
  // double型的浮点数密度高，1e-7在4ULP以外
  // ASSERT_DOUBLE_EQ(1.0000001, 1.0); 失败
  ASSERT_NEAR(1.009f,1.0f,0.01f);
  // 谓词逻辑
  EXPECT_PRED_FORMAT2(::testing::FloatLE, 1.0000001f, 1.0f);
}

TEST(GeneralTest, GMockMatcher)
{
  const std::string str("Hello 123 world!");
  EXPECT_THAT(str, ::testing::StartsWith("Hello"));
  EXPECT_THAT(str, ::testing::EndsWith("world!"));
  ASSERT_THAT(str, ::testing::HasSubstr("llo"));
  EXPECT_THAT(str, ::testing::MatchesRegex(".*[1-9]{3}.*"));
}

bool equal(int m, int n)
{
  return m==n;
}

// A predicate-formatter for asserting that two integers are equal
testing::AssertionResult AssertEqual(const char* m_expr,
                                     const char* n_expr,
                                     int m,
                                     int n) {
  if (equal(m, n)) return testing::AssertionSuccess();

  return testing::AssertionFailure() << m_expr << " and " << n_expr
      << " (" << m << " and " << n << ") are not equal, "
      << "as they are " << m-n << " apart.";
}
TEST(GeneralTest, PredAssertion)
{
  const int m = 1;
  const int n = 1;
  EXPECT_PRED2(equal, m, n);
  EXPECT_PRED_FORMAT2(AssertEqual, m, n);
}
}  // namespace

// 大多数情况下，我们不需要修改此主函数，显得有些多余
// gtest提供了方法让我们可以删除此主函数，只需在链接时
// 链接GTEST_MAIN_LIBRARIES。
int main(int argc,char **argv){
  testing::InitGoogleTest(&argc,argv);
  return RUN_ALL_TESTS();
}
```

编译所需的CMakeLists.txt

```C++
cmake_minimum_required(VERSION 3.0)

project(gtest_example)

# must include 
include(CTest)

# find GTest and gmock
find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIR})
find_package(GMock REQUIRED)
include_directories(${GMOCK_INCLUDE_DIR})

enable_testing()

add_executable(free_functions_gtest free_functions_gtest.cc)
# 如果gtest使用pthread编译安装，需要添加pthread依赖
target_link_libraries(free_functions_gtest ${GTEST_LIBRARIES} ${GMOCK_LIBRARIES} pthread)

add_test(NAME dummy_test
         COMMAND free_functions_gtest)
```

#### 值参数化测试样例

函数指针作为值进行参数化测试样例

```C++
// Copyright 2008 Google Inc.
// All Rights Reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


// This sample shows how to test common properties of multiple
// implementations of an interface (aka interface tests) using
// value-parameterized tests. Each test in the test case has
// a parameter that is an interface pointer to an implementation
// tested.

// The interface and its implementations are in this header.
#include "prime_tables.h"

#include "gtest/gtest.h"
namespace {

    using ::testing::TestWithParam;
    using ::testing::Values;

    // As a general rule, to prevent a test from affecting the tests that come
    // after it, you should create and destroy the tested objects for each test
    // instead of reusing them.  In this sample we will define a simple factory
    // function for PrimeTable objects.  We will instantiate objects in test's
    // SetUp() method and delete them in TearDown() method.
    typedef PrimeTable* CreatePrimeTableFunc();

    PrimeTable* CreateOnTheFlyPrimeTable() {
        return new OnTheFlyPrimeTable();
    }

    template <size_t max_precalculated>
    PrimeTable* CreatePreCalculatedPrimeTable() {
        return new PreCalculatedPrimeTable(max_precalculated);
    }

    // Inside the test body, fixture constructor, SetUp(), and TearDown() you
    // can refer to the test parameter by GetParam().  In this case, the test
    // parameter is a factory function which we call in fixture's SetUp() to
    // create and store an instance of PrimeTable.
    class PrimeTableTestSmpl7 : public TestWithParam<CreatePrimeTableFunc*> {
        public:
        ~PrimeTableTestSmpl7() override { delete table_; }
        void SetUp() override { table_ = (*GetParam())(); }
        void TearDown() override {
            delete table_;
            table_ = nullptr;
        }

        protected:
        PrimeTable* table_;
    };

    TEST_P(PrimeTableTestSmpl7, ReturnsFalseForNonPrimes) {
        EXPECT_FALSE(table_->IsPrime(-5));
        EXPECT_FALSE(table_->IsPrime(0));
        EXPECT_FALSE(table_->IsPrime(1));
        EXPECT_FALSE(table_->IsPrime(4));
        EXPECT_FALSE(table_->IsPrime(6));
        EXPECT_FALSE(table_->IsPrime(100));
    }

    TEST_P(PrimeTableTestSmpl7, ReturnsTrueForPrimes) {
        EXPECT_TRUE(table_->IsPrime(2));
        EXPECT_TRUE(table_->IsPrime(3));
        EXPECT_TRUE(table_->IsPrime(5));
        EXPECT_TRUE(table_->IsPrime(7));
        EXPECT_TRUE(table_->IsPrime(11));
        EXPECT_TRUE(table_->IsPrime(131));
    }

    TEST_P(PrimeTableTestSmpl7, CanGetNextPrime) {
        EXPECT_EQ(2, table_->GetNextPrime(0));
        EXPECT_EQ(3, table_->GetNextPrime(2));
        EXPECT_EQ(5, table_->GetNextPrime(3));
        EXPECT_EQ(7, table_->GetNextPrime(5));
        EXPECT_EQ(11, table_->GetNextPrime(7));
        EXPECT_EQ(131, table_->GetNextPrime(128));
    }

    // In order to run value-parameterized tests, you need to instantiate them,
    // or bind them to a list of values which will be used as test parameters.
    // You can instantiate them in a different translation module, or even
    // instantiate them several times.
    //
    // Here, we instantiate our tests with a list of two PrimeTable object
    // factory functions:
    INSTANTIATE_TEST_SUITE_P(OnTheFlyAndPreCalculated, PrimeTableTestSmpl7,
                             Values(&CreateOnTheFlyPrimeTable,
                                    &CreatePreCalculatedPrimeTable<1000>));

}  // namespace
```

std::tuple作为值进行参数化测试样例

```c++
// Copyright 2008 Google Inc.
// All Rights Reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


// This sample shows how to test code relying on some global flag variables.
// Combine() helps with generating all possible combinations of such flags,
// and each test is given one combination as a parameter.

// Use class definitions to test from this header.
#include "prime_tables.h"

#include "gtest/gtest.h"
namespace {

    // Suppose we want to introduce a new, improved implementation of PrimeTable
    // which combines speed of PrecalcPrimeTable and versatility of
    // OnTheFlyPrimeTable (see prime_tables.h). Inside it instantiates both
    // PrecalcPrimeTable and OnTheFlyPrimeTable and uses the one that is more
    // appropriate under the circumstances. But in low memory conditions, it can be
    // told to instantiate without PrecalcPrimeTable instance at all and use only
    // OnTheFlyPrimeTable.
    class HybridPrimeTable : public PrimeTable {
        public:
        HybridPrimeTable(bool force_on_the_fly, int max_precalculated)
            : on_the_fly_impl_(new OnTheFlyPrimeTable),
        precalc_impl_(force_on_the_fly
                      ? nullptr
                      : new PreCalculatedPrimeTable(max_precalculated)),
        max_precalculated_(max_precalculated) {}
        ~HybridPrimeTable() override {
            delete on_the_fly_impl_;
            delete precalc_impl_;
        }

        bool IsPrime(int n) const override {
            if (precalc_impl_ != nullptr && n < max_precalculated_)
                return precalc_impl_->IsPrime(n);
            else
                return on_the_fly_impl_->IsPrime(n);
        }

        int GetNextPrime(int p) const override {
            int next_prime = -1;
            if (precalc_impl_ != nullptr && p < max_precalculated_)
                next_prime = precalc_impl_->GetNextPrime(p);

            return next_prime != -1 ? next_prime : on_the_fly_impl_->GetNextPrime(p);
        }

        private:
        OnTheFlyPrimeTable* on_the_fly_impl_;
        PreCalculatedPrimeTable* precalc_impl_;
        int max_precalculated_;
    };

    using ::testing::TestWithParam;
    using ::testing::Bool;
    using ::testing::Values;
    using ::testing::Combine;

    // To test all code paths for HybridPrimeTable we must test it with numbers
    // both within and outside PreCalculatedPrimeTable's capacity and also with
    // PreCalculatedPrimeTable disabled. We do this by defining fixture which will
    // accept different combinations of parameters for instantiating a
    // HybridPrimeTable instance.
    class PrimeTableTest : public TestWithParam< ::std::tuple<bool, int> > {
        protected:
        void SetUp() override {
            bool force_on_the_fly;
            int max_precalculated;
            std::tie(force_on_the_fly, max_precalculated) = GetParam();
            table_ = new HybridPrimeTable(force_on_the_fly, max_precalculated);
        }
        void TearDown() override {
            delete table_;
            table_ = nullptr;
        }
        HybridPrimeTable* table_;
    };

    TEST_P(PrimeTableTest, ReturnsFalseForNonPrimes) {
        // Inside the test body, you can refer to the test parameter by GetParam().
        // In this case, the test parameter is a PrimeTable interface pointer which
        // we can use directly.
        // Please note that you can also save it in the fixture's SetUp() method
        // or constructor and use saved copy in the tests.

        EXPECT_FALSE(table_->IsPrime(-5));
        EXPECT_FALSE(table_->IsPrime(0));
        EXPECT_FALSE(table_->IsPrime(1));
        EXPECT_FALSE(table_->IsPrime(4));
        EXPECT_FALSE(table_->IsPrime(6));
        EXPECT_FALSE(table_->IsPrime(100));
    }

    TEST_P(PrimeTableTest, ReturnsTrueForPrimes) {
        EXPECT_TRUE(table_->IsPrime(2));
        EXPECT_TRUE(table_->IsPrime(3));
        EXPECT_TRUE(table_->IsPrime(5));
        EXPECT_TRUE(table_->IsPrime(7));
        EXPECT_TRUE(table_->IsPrime(11));
        EXPECT_TRUE(table_->IsPrime(131));
    }

    TEST_P(PrimeTableTest, CanGetNextPrime) {
        EXPECT_EQ(2, table_->GetNextPrime(0));
        EXPECT_EQ(3, table_->GetNextPrime(2));
        EXPECT_EQ(5, table_->GetNextPrime(3));
        EXPECT_EQ(7, table_->GetNextPrime(5));
        EXPECT_EQ(11, table_->GetNextPrime(7));
        EXPECT_EQ(131, table_->GetNextPrime(128));
    }

    // In order to run value-parameterized tests, you need to instantiate them,
    // or bind them to a list of values which will be used as test parameters.
    // You can instantiate them in a different translation module, or even
    // instantiate them several times.
    //
    // Here, we instantiate our tests with a list of parameters. We must combine
    // all variations of the boolean flag suppressing PrecalcPrimeTable and some
    // meaningful values for tests. We choose a small value (1), and a value that
    // will put some of the tested numbers beyond the capability of the
    // PrecalcPrimeTable instance and some inside it (10). Combine will produce all
    // possible combinations.
    INSTANTIATE_TEST_SUITE_P(MeaningfulTestParameters, PrimeTableTest,
                             Combine(Bool(), Values(1, 10)));

}  // namespace

```

#### 类型数化测试样例

```C++
// Copyright 2008 Google Inc.
// All Rights Reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


// This sample shows how to test common properties of multiple
// implementations of the same interface (aka interface tests).

// The interface and its implementations are in this header.
#include "prime_tables.h"

#include "gtest/gtest.h"
namespace {
// First, we define some factory functions for creating instances of
// the implementations.  You may be able to skip this step if all your
// implementations can be constructed the same way.

template <class T>
PrimeTable* CreatePrimeTable();

template <>
PrimeTable* CreatePrimeTable<OnTheFlyPrimeTable>() {
  return new OnTheFlyPrimeTable;
}

template <>
PrimeTable* CreatePrimeTable<PreCalculatedPrimeTable>() {
  return new PreCalculatedPrimeTable(10000);
}

// Then we define a test fixture class template.
template <class T>
class PrimeTableTest : public testing::Test {
 protected:
  // The ctor calls the factory function to create a prime table
  // implemented by T.
  PrimeTableTest() : table_(CreatePrimeTable<T>()) {}

  ~PrimeTableTest() override { delete table_; }

  // Note that we test an implementation via the base interface
  // instead of the actual implementation class.  This is important
  // for keeping the tests close to the real world scenario, where the
  // implementation is invoked via the base interface.  It avoids
  // got-yas where the implementation class has a method that shadows
  // a method with the same name (but slightly different argument
  // types) in the base interface, for example.
  PrimeTable* const table_;
};

#if GTEST_HAS_TYPED_TEST

using testing::Types;

// Google Test offers two ways for reusing tests for different types.
// The first is called "typed tests".  You should use it if you
// already know *all* the types you are gonna exercise when you write
// the tests.

// To write a typed test case, first use
//
//   TYPED_TEST_SUITE(TestCaseName, TypeList);
//
// to declare it and specify the type parameters.  As with TEST_F,
// TestCaseName must match the test fixture name.

// The list of types we want to test.
typedef Types<OnTheFlyPrimeTable, PreCalculatedPrimeTable> Implementations;

TYPED_TEST_SUITE(PrimeTableTest, Implementations);

// Then use TYPED_TEST(TestCaseName, TestName) to define a typed test,
// similar to TEST_F.
TYPED_TEST(PrimeTableTest, ReturnsFalseForNonPrimes) {
  // Inside the test body, you can refer to the type parameter by
  // TypeParam, and refer to the fixture class by TestFixture.  We
  // don't need them in this example.

  // Since we are in the template world, C++ requires explicitly
  // writing 'this->' when referring to members of the fixture class.
  // This is something you have to learn to live with.
  EXPECT_FALSE(this->table_->IsPrime(-5));
  EXPECT_FALSE(this->table_->IsPrime(0));
  EXPECT_FALSE(this->table_->IsPrime(1));
  EXPECT_FALSE(this->table_->IsPrime(4));
  EXPECT_FALSE(this->table_->IsPrime(6));
  EXPECT_FALSE(this->table_->IsPrime(100));
}

TYPED_TEST(PrimeTableTest, ReturnsTrueForPrimes) {
  EXPECT_TRUE(this->table_->IsPrime(2));
  EXPECT_TRUE(this->table_->IsPrime(3));
  EXPECT_TRUE(this->table_->IsPrime(5));
  EXPECT_TRUE(this->table_->IsPrime(7));
  EXPECT_TRUE(this->table_->IsPrime(11));
  EXPECT_TRUE(this->table_->IsPrime(131));
}

TYPED_TEST(PrimeTableTest, CanGetNextPrime) {
  EXPECT_EQ(2, this->table_->GetNextPrime(0));
  EXPECT_EQ(3, this->table_->GetNextPrime(2));
  EXPECT_EQ(5, this->table_->GetNextPrime(3));
  EXPECT_EQ(7, this->table_->GetNextPrime(5));
  EXPECT_EQ(11, this->table_->GetNextPrime(7));
  EXPECT_EQ(131, this->table_->GetNextPrime(128));
}

// That's it!  Google Test will repeat each TYPED_TEST for each type
// in the type list specified in TYPED_TEST_SUITE.  Sit back and be
// happy that you don't have to define them multiple times.

#endif  // GTEST_HAS_TYPED_TEST

#if GTEST_HAS_TYPED_TEST_P

using testing::Types;

// Sometimes, however, you don't yet know all the types that you want
// to test when you write the tests.  For example, if you are the
// author of an interface and expect other people to implement it, you
// might want to write a set of tests to make sure each implementation
// conforms to some basic requirements, but you don't know what
// implementations will be written in the future.
//
// How can you write the tests without committing to the type
// parameters?  That's what "type-parameterized tests" can do for you.
// It is a bit more involved than typed tests, but in return you get a
// test pattern that can be reused in many contexts, which is a big
// win.  Here's how you do it:

// First, define a test fixture class template.  Here we just reuse
// the PrimeTableTest fixture defined earlier:

template <class T>
class PrimeTableTest2 : public PrimeTableTest<T> {
};

// Then, declare the test case.  The argument is the name of the test
// fixture, and also the name of the test case (as usual).  The _P
// suffix is for "parameterized" or "pattern".
TYPED_TEST_SUITE_P(PrimeTableTest2);

// Next, use TYPED_TEST_P(TestCaseName, TestName) to define a test,
// similar to what you do with TEST_F.
TYPED_TEST_P(PrimeTableTest2, ReturnsFalseForNonPrimes) {
  EXPECT_FALSE(this->table_->IsPrime(-5));
  EXPECT_FALSE(this->table_->IsPrime(0));
  EXPECT_FALSE(this->table_->IsPrime(1));
  EXPECT_FALSE(this->table_->IsPrime(4));
  EXPECT_FALSE(this->table_->IsPrime(6));
  EXPECT_FALSE(this->table_->IsPrime(100));
}

TYPED_TEST_P(PrimeTableTest2, ReturnsTrueForPrimes) {
  EXPECT_TRUE(this->table_->IsPrime(2));
  EXPECT_TRUE(this->table_->IsPrime(3));
  EXPECT_TRUE(this->table_->IsPrime(5));
  EXPECT_TRUE(this->table_->IsPrime(7));
  EXPECT_TRUE(this->table_->IsPrime(11));
  EXPECT_TRUE(this->table_->IsPrime(131));
}

TYPED_TEST_P(PrimeTableTest2, CanGetNextPrime) {
  EXPECT_EQ(2, this->table_->GetNextPrime(0));
  EXPECT_EQ(3, this->table_->GetNextPrime(2));
  EXPECT_EQ(5, this->table_->GetNextPrime(3));
  EXPECT_EQ(7, this->table_->GetNextPrime(5));
  EXPECT_EQ(11, this->table_->GetNextPrime(7));
  EXPECT_EQ(131, this->table_->GetNextPrime(128));
}

// Type-parameterized tests involve one extra step: you have to
// enumerate the tests you defined:
REGISTER_TYPED_TEST_SUITE_P(
    PrimeTableTest2,  // The first argument is the test case name.
    // The rest of the arguments are the test names.
    ReturnsFalseForNonPrimes, ReturnsTrueForPrimes, CanGetNextPrime);

// At this point the test pattern is done.  However, you don't have
// any real test yet as you haven't said which types you want to run
// the tests with.

// To turn the abstract test pattern into real tests, you instantiate
// it with a list of types.  Usually the test pattern will be defined
// in a .h file, and anyone can #include and instantiate it.  You can
// even instantiate it more than once in the same program.  To tell
// different instances apart, you give each of them a name, which will
// become part of the test case name and can be used in test filters.

// The list of types we want to test.  Note that it doesn't have to be
// defined at the time we write the TYPED_TEST_P()s.
typedef Types<OnTheFlyPrimeTable, PreCalculatedPrimeTable>
    PrimeTableImplementations;
INSTANTIATE_TYPED_TEST_SUITE_P(OnTheFlyAndPreCalculated,    // Instance name
                               PrimeTableTest2,             // Test case name
                               PrimeTableImplementations);  // Type list

#endif  // GTEST_HAS_TYPED_TEST_P
}  // namespace

```

